\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{okithm}[2019/01/27 v0.3]


% ======== Options ========
\RequirePackage{kvoptions}

\DeclareBoolOption[true]{theorems}
\DeclareComplementaryOption{notheorem}{theorems}
\DeclareStringOption[English]{language}
\DeclareBoolOption[true]{algorithms}
\DeclareComplementaryOption{noalgorithm}{algorithms}
\DeclareStringOption[section]{numberwithin}
\DeclareStringOption[long]{optstyle}
\ProcessKeyvalOptions*{}


% ======== Theorems ========

\ifokithm@theorems
  \RequirePackage{amsthm}
  \RequirePackage{thmtools}
  \RequirePackage{translations}
  \RequirePackage{xstring}
  
  \DeclareTranslation{English}{theorem}{Theorem}
  \DeclareTranslation{English}{definition}{Definition}
  \DeclareTranslation{English}{lemma}{Lemma}
  \DeclareTranslation{English}{proposition}{Proposition}
  \DeclareTranslation{English}{corollary}{Corollary}
  \DeclareTranslation{English}{example}{Example}
  \DeclareTranslation{English}{remark}{Remark}
  \DeclareTranslation{English}{proof}{Proof}
  
  \DeclareTranslation{Japanese}{theorem}{定理}
  \DeclareTranslation{Japanese}{definition}{定義}
  \DeclareTranslation{Japanese}{lemma}{補題}
  \DeclareTranslation{Japanese}{proposition}{命題}
  \DeclareTranslation{Japanese}{corollary}{系}
  \DeclareTranslation{Japanese}{example}{例}
  \DeclareTranslation{Japanese}{proof}{証明}
  
  \declaretheoremstyle{defstyle}
  \declaretheoremstyle[qed=\qedsymbol]{exstyle}
  
  \IfStrEq{\okithm@language}{Japanese}{%
    \declaretheoremstyle{thmstyle}
    \declaretheoremstyle[qed=\qedsymbol]{proofstyle}
  }{%
    \declaretheoremstyle[bodyfont=\normalfont\itshape]{thmstyle}
    \declaretheoremstyle[headfont=\normalfont\itshape,qed=\qedsymbol]{proofstyle}
  }

  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{theorem},%
    style=thmstyle,%
    numberwithin=\okithm@numberwithin%
  ]{theorem}
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{definition},%
    style=defstyle,%
    sibling=theorem%
  ]{definition}
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{lemma},%
    style=thmstyle,%
    sibling=theorem%
  ]{lemma}
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{proposition},%
    style=thmstyle,%
    sibling=theorem%
  ]{proposition}
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{corollary},%
    style=thmstyle,%
    sibling=theorem%
  ]{corollary}
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{example},%
    style=exstyle,%
    sibling=theorem%
  ]{example}
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{remark},%
    style=defstyle,%
    sibling=theorem%
  ]{remark}

  \let\proof\@undefined
  \let\endproof\@undefined
  \declaretheorem[%
    name=\GetTranslationFor{\okithm@language}{proof},%
    style=proofstyle,%
    numbered=no%
  ]{proof}
\fi


% ======== Algorithm ========
\ifokithm@algorithms
  \RequirePackage{algorithm}
  \RequirePackage[noend]{algpseudocode}

  \algnewcommand{\algorithmicinput}{\makebox[\widthof{\textbf{Output}}][l]{\textbf{Input}}\textbf{:}}
  \algnewcommand{\Input}{\item[\algorithmicinput]}
  \algnewcommand{\algorithmicoutput}{\textbf{Output:}}
  \algnewcommand{\Output}{\item[\algorithmicoutput]}

  \algnewcommand{\algorithmicto}{\textbf{to}}
  \algdef{SE}[FOR]{ForTo}{EndFor}[2]{\algorithmicfor\ #1 \algorithmicto\ #2 \algorithmicdo}{\algorithmicend\ \algorithmicfor}\algtext*{EndFor}
\fi

% ======== Optimization Problem ========
\RequirePackage{array}
\RequirePackage{xkeyval}

\define@cmdkeys{Minimizekey}[optprob@]{name, variable}
\define@choicekey*{Minimizekey}{style}[\val]{short,long}{\def\optprob@style{\val}}

\def\okithm@makeoptprob#1#2#3#4#5{%
  % #1 : options
  % #2 : minimize
  % #3 : object function
  % #4 : subject to
  % #5 : constraints
  \setkeys{Minimizekey}{#1}%
  \begin{align}%
    \ifdefined\optprob@name%
      \text{\optprob@name}\quad%
  	\fi%
    \begin{array}{|cl}%
      \ifdefined\optprob@variable%
        $\underset{\optprob@variable}{\mathrm{#2}}$%
      \else%
        \text{#2}%
      \fi%
      &\hspace{-1em}$\begin{array}[t]{l}\displaystyle#3\end{array}$ \\
      \text{#4}%
      &\hspace{-1em}$\begin{array}[t]{>{\displaystyle}l<{}>{\displaystyle}l<{}}#5\end{array}$%
    \end{array}%
  \end{align}
  \let\optprob@name\undefined%
  \let\optprob@variable\undefined%
  \let\optprob@style\undefined%
}

\def\okithm@DeclareOptProb#1#2#3#4#5{%
  % #1 : name of the command
  % #2 : minimize
  % #3 : min
  % #4 : subject to
  % #5 : s.t.
  \newcommand#1[3][]{%
    \setkeys{Minimizekey}{##1}%
    \ifdefined\optprob@style\else
      \def\optprob@style{\okithm@optstyle}
    \fi
    \ifthenelse{\equal{\optprob@style}{long}}{%
      \okithm@makeoptprob{##1}{#2}{##2}{#4}{##3}%
    }{%
      \okithm@makeoptprob{##1}{#3}{##2}{#5}{##3}%
    }%
  }%
}

\okithm@DeclareOptProb{\Minimize}{minimize}{min}{subject to}{s.t.}
\okithm@DeclareOptProb{\Maximize}{maximize}{max}{subject to}{s.t.}

% ======== Enumeration ========
\RequirePackage{enumitem}

\setlist{font=\upshape,leftmargin=*}
\setlist[1]{labelindent=\parindent}
\setlist[enumerate,1]{label={(\arabic*)}}
\setlist[enumerate,2]{label={(\arabic{enumi}-\arabic*)}}
\setlist[enumerate,3]{label={(\arabic{enumi}-\arabic{enumii}-\arabic*)}}
